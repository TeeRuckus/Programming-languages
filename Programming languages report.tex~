\documentclass[
	12pt, % Default font size, values between 10pt-12pt are allowed
	%letterpaper, % Uncomment for US letter paper size
	%spanish, % Uncomment for Spanish
]{fphw}

% Template-specific packages
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{mathpazo} % Use the Palatino font
\usepackage{graphicx} % Required for including images
\usepackage{subfig}
\graphicspath{{figures/}}
\usepackage{array}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs} % Required for better horizontal rules in tables
\usepackage{listings} % Required for insertion of code
\usepackage{enumerate} % To modify the enumerate environment
\usepackage[section]{placeins}
\usepackage{wrapfig}
\usepackage{pdfpages}
\usepackage[section]{placeins}
\usepackage{flafter}
%trying to do referencing using Chicago style
%NEW SHIT HERE
\usepackage{appendix}
%delete after, this is to place dummy text on the page
\usepackage[english]{babel}
\usepackage{setspace}
\usepackage{csquotes}
%how to use this package. Do your code snippets last, as you need to move the .m file into
%the same directory as this tex file

%adding a box around my imported latex code
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}\lstset{frame=single, rulesepcolor=\color{black}, numbers=left}

\lstset{language=Matlab,%
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    numbers=left,%
    numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=9pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    emph=[2]{word1,word2}, emphstyle=[2]{style},
}

\usepackage[authordate]{biblatex-chicago}
\DeclareFieldFormat[article]{title}{\mkbibquote{#1}} % make article titles in quotes
\DeclareFieldFormat[thesis]{title}{\mkbibemph{#1}} % make theses italics
\bibliography{Programming languages report}

\counterwithin*{equation}{section}
\counterwithin*{equation}{subsection}
\counterwithin*{equation}{subsubsection}

%CHANGE
%I want to save space when I am writing my document, so I am going to have
%everything as the default values for the system
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{1.5em}
%\onehalfspacing
%\setstretch{1.25}
%making a variable for where all my results are going to be stored
\newcommand\pathFiles{"summary/"}
%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Programming Languages Assignment} % Assignment title
\author{Tawana Kwaramba: 19476700} % Student name
\date{October 25th, 2021} % Due date
\institute{Curtin University \\ Faculty of Science and Engineering: School of Electrical Engineering, computing and Math Science} % Institute or school name
\class{Programming Languages - COMP2007} % Course or class name
\professor{Ascsociate Lecturer: Arlen Brower}
%----------------------------------------------------------------------------------------

\begin{document}
\pagenumbering{gobble}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
%\newpage
\listoftables
\newpage
%\end{spacing}
\pagenumbering{arabic}
%----------------------------------------------------------------------------------------
%	Programming Languages Report
%----------------------------------------------------------------------------------------

\section{Introduction}
you will need to write this one last, as you will need to know what you're
talking about each of the sections which you're coding for

\section{Fortran}

\subsection{Fortran: Discussion}
Fortran was a first generation programming language which was mainly based on
the punch card system which was used at the times \textbf{site me}.
Fortran was a language intended for mathematical operations which can be used
in the field of engineering and applied sciences. The name Fortran embodies this
purpose as Fortran stands for \emph{Formula translator}.\par

Due to Fortran being based on the punch card system this imposed specific
rules on the programming language.Including the following:
the first column of each row is going to be reserved for
the comment character which is either "c" or "*"; column one to five of each row
are going to be reserved for statements or labels; column six is going to be
reserved for the continuation of a command from the previous line; each of your
commands given a row much terminate on column seventy-two; and column seventy-three
to eighty are going to be reserved for sequence numbers, to just name few of the rules
which are going to emposed onto Fortran. As a consquence of some of these rules,
this made Fortran more intellectually involving compared to previously written
languages
of the plethora of rules
to be memorised this made it more intellectually involving as compared to
previoulsy written languages of Java, C, and Python. \par

\subsubsection{Fortran: Comparison with written languages}

While writting the fizzbuzz programme in Fortran I noticed I was thinking more than I typically would be
while programming, and fortran has a lot of similarities to the named programming
languages. \par

While programming in Fortran I had be consistently worrying about the current
column numbber which I was currently in, this is not a behaviour I typically
do while writing C, Java, and Python programs. Typically writting these languages
I don't really care which line number or column in, I would typically choose to
keep each line below 80 characters to make it easier for others to read the my code.
Although, in Fortran this is going to be a hard imposed rule. \par

Furthermore, Fortran variables can be only limited to one to six characters long
therefore, while I was programming I had to always double check my variable names
to ensure that they're going to be below six characters hence, limiting my expressivity
in the purpose of variable. As compared to the name programming languages, I didn't
have to think about the length of my variable names I typically would make them
a length which is going to be sufficient in discribing their purpose hence, in the
named programming languages I was able to express myself more. \par


Additionally, due to the lack of reserved words in the Fortran language, I had  to
always double check all my Fortran variables didn't have any other intended
purposes as the Fortran complier will not tell you if a variable was reserved or
not, and it will just allow you to override that variable. As compared to the named
programmed languages I would typically just express the problem in the language,
and rely on the compilier to warn me if I have tried to override a reserved word.
Therefore, while programming in Fortran I had to rely more on myself, and in other
languages I can rely more on the complier.\par

Lastly, in Fortran if you had forgetten to declare a variable the fortran
complier would not warn you of your mistake but, instead will print our a random
memory address. As compared to the name programming languages, the complier
would warn you of your mistake immeditely and the line number which the mistake
had occured. Therefore in Fortran you would have to spend more time debugging
the code at hand.\par

Similarities of Fotran as compared to the named programming languages is that
the first character of each variable has to start with a letter and can't start
with a number, Fortran will require you to declare the types of your variables
same as C, and Java. Furthermore, Fortran will require the programme field to be
the same name as the current file name which is a similar idea which is seen in
Java wherby the file name has to be the same as the class name, and Fortran will
require terminating statements for each command as seing in languages such as
Java, and C.

\subsection{Fortran: Reflection}

Fortran doesn't really have any scope as consquence, you were planning to build
a full operational programme all the variables can be accesssed from anywhere
therefore, unattended side affects may occur in the excution of the programme as
the variables can be modified by anything as they're not protected by scope.
Therefore, this is going to make it harder to debugg the current programme, as the
programmer would have to have full knowledge of the programme as a hole instead
of knowledged of the current scopes. As a consqunce, this is going to make Fortran
diffucult to strucuture code in the appropriate heirachies hence, violating the
\emph{structured programming principle}. Additionally, since they is not really
any scope in Fortran this is going to make it hard to hide the implmentations of
any subroutines and fucntions therefore violating the \emph{information hiding
principle}.\par


As discussed in the previous section the Fortran complier is not helpful as it
doesn't warn the programmer of common programming mistakes. Therefore, one small
mistak made by the programme can result of the built programme not running as
intetended. The complier in modern languages is more of a helping guide in writing
correct and relabile code therefore, since Fortran complier doesn't warn the
programmer about these mistakes this makes the programmes exprience less reliable
violiting the \emph{reliability principle}.\par

In relation to Fortran violating the \emph{reliability principle}, the complier
will see all commands and variables as upper cases hence, making the language
case insensitive. Further adding on onto the unrealiblity of the Fortran
programming language.\par

As discussed previously Fortran variable names will have to be between one to
six characters long. The principle of \emph{zero one ifinity} outlines thtat the
only valid length of anything is going to be either one, zero or ifinity. As can
be seeing with the variable length names Fortran clearly violates the
\emph{zero one ifinity} principle.

\textbf{talk about how it violates the readibility principle}

\subsection{Fortran: Testing and compiling}
\textbf{you will actually need to go and do this at uni}

\subsubsection{Results from running programme}
\textbf{you will actually need to go and do this at uni}

\section{Algo68}

\subsection{Algo 68: Fizzbuzz activation record}
\textbf{Don't forget a picture of it here dawg}

\subsection{Algo 68: Reflectoin}
Writting the fizz buzz programme with Algo 68 was more plesant than Fortran. Algo
68 is starting to represent the langauges which we're more accostumed too. Alog 68
strongly reminds me of the bash scripting language as the constructs are going
to end with a word instead of terminating delimeter. \par

Algo 68 is going to be a language which is going to be scopped hence, the
variables which are in a \emph{BEGIN} and \emph{END} block are only going to be
found to be accessed within that block, and variables which are going to be defined
in any given construct are going to be only accessed within those constructs.
Therefore in Algo 68 you're not going to get the side effects whichy you may get in
Fortran as the variables are going to be protected by scope therfore, Algo 68
adhering to the \emph{information hiding principle}. \par

Additionally, due to the introduction of scope, and the introduction of clear
termination of constructs, it's a lot easier to look at an Algo 68 programme and
get a good idea on what the intededed purpose of the programme is going to be
hence, adhering to the \emph{readability principle}. Since, the algo-68 is going
to be highly structured this also adheres to the \emph{structured programming}
principle. As a consquence to these observation, wrting a programme in Algo-68
was a lot easier than writing a programme in Fortran.

\section{ADA}
\subsection{ADA: comparison with other buble sorts}
A difference between the two lagnauges is going to be the way which they treat
fucntions. In C the construction of function which will return nothing or something
is going to have the same prototype, ADA will actually will clearly segement these
two classes of functions. Functions which are going to return nothing are going
to be referred to as \emph{procedures}, and functions which are going to return
something are going to be refferred to as \emph{sub-routines}. \par

A difference between C and ADA is going to be the choice of terminating characters
for commands. In C the end of a construct such as a "if and else" statement will
need to be terminated withe a semi-colon, and in C the end of a "if and else"
statement is going to be terminated with a right parenthesis.\par

A similarity between C and ADA implementation is going to be found in the
positioning of the functions in the file. In C this phenomenon is going to be
refferred to as forward declartion whereby, the functions (procedures) have to
be declared before the main body of code otherwise both the ADA and C compilier
will complain that it doesn't kow what the following funciton is going to be. This
idea will also extend to variable decelartoin positioning as well, in C-89
variables will have to be decaled first before any commands are written, and in
ADA variables and types will have to be declared before the \emph{begin} key word.\par

Another similarity point between the ADA and C implementation is going to be the
use of pointer manipulation in order to swap any element which is going to be greater
than the element which is going to be infront of it as both algorithms will
derefrence that memory location to get what is going to be stored their.\par

C and ADA are going to be both strongly type languages. Meaning that that a variable
or a data structure must be declared with a type before they're going to be used.
This idea will extend to function imports as well, the type of the imports must be
declared before use

\textbf{come back to this, I don't feel like writing it more}

Furthermore, ADA and C will both require you to import packages in order to be able
to do simple commands such as print a satement to the screen, and to use data
strucutres such as arrays. \par

\subsection{ADA: reflection}


\end{document}
